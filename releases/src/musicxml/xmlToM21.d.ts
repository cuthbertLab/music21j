import * as chord from '../chord';
import * as clef from '../clef';
import * as duration from '../duration';
import * as key from '../key';
import * as meter from '../meter';
import * as note from '../note';
import * as pitch from '../pitch';
import * as stream from '../stream';
import * as tie from '../tie';
import type { Music21Object } from '../base';
export declare class ScoreParser {
    xmlText: string;
    xmlUrl: string;
    xmlRoot: Element;
    stream: stream.Score;
    definesExplicitSystemBreaks: boolean;
    definesExplicitPageBreaks: boolean;
    mxScorePartDict: {};
    m21PartObjectsById: {};
    partGroupList: any[];
    parts: any[];
    musicXmlVersion: string;
    constructor();
    scoreFromUrl(url: string): Promise<stream.Score>;
    scoreFromText(xmlText: string): stream.Score;
    scoreFromDOMTree(xmlDoc: Document): stream.Score;
    xmlRootToScore(mxScore: Element, inputM21: stream.Score): stream.Score;
    xmlPartToPart(mxPart: Element, mxScorePart: Element): stream.Part;
    parsePartList(mxScore: Element): void;
}
export declare class PartParser {
    parent: ScoreParser;
    mxPart: Element;
    mxScorePart: Element;
    partId: string;
    stream: stream.Part;
    atSoundingPitch: boolean;
    staffReferenceList: any[];
    lastTimeSignature: meter.TimeSignature;
    lastMeasureWasShort: boolean;
    lastMeasureOffset: number;
    lastClefs: Record<number, clef.Clef>;
    activeTuplets: any[];
    maxStaves: number;
    lastMeasureNumber: number;
    lastNumberSuffix: string;
    multiMeasureRestsToCapture: number;
    firstMeasureParsed: boolean;
    activeAttributes: Element;
    lastDivisions: number;
    appendToScoreAfterParse: boolean;
    lastMeasureParser: MeasureParser;
    constructor(mxPart: Element, mxScorePart: Element, parent?: ScoreParser);
    parse(): void;
    parseXmlScorePart(): void;
    parseMeasures(): void;
    xmlMeasureToMeasure(mxMeasure: Element): void;
    setLastMeasureInfo(m: stream.Measure): void;
    adjustTimeAttributesFromMeasure(m: stream.Measure): void;
    separateOutPartStaves(): void;
}
export declare class MeasureParser {
    mxMeasure: Element;
    parent: PartParser;
    mxMeasureElements: Element[];
    stream: stream.Measure;
    divisions: any;
    transposition: any;
    staffReference: {};
    useVoices: boolean;
    voicesById: {};
    voiceIndices: any;
    staves: number;
    activeAttributes: any;
    attributesAreInternal: boolean;
    measureNumber: number;
    numberSuffix: string;
    staffLayoutObjects: any[];
    mxNoteList: any[];
    mxLyricList: any[];
    nLast: note.GeneralNote;
    chordVoice: any;
    fullMeasureRest: boolean;
    restAndNoteCount: {
        rest: number;
        note: number;
    };
    lastClefs: {
        0: any;
    };
    parseIndex: number;
    offsetMeasureNote: number;
    attributeTagsToMethods: {
        time: string;
        clef: string;
        key: string;
    };
    musicDataMethods: {
        note: string;
        backup: string;
        forward: string;
        attributes: string;
    };
    constructor(mxMeasure: Element, parent?: PartParser);
    parse(): void;
    getStaffNumber(mxObj: Element): number;
    addToStaffReference(mxObj: Element, m21obj: Music21Object): void;
    insertInMeasureOrVoice(mxObj: Element, el: Music21Object): void;
    xmlToNote(mxNote: Element): void;
    xmlToChord(mxNoteList: Element[]): chord.Chord;
    xmlToSimpleNote(mxNote: any, freeSpanners?: boolean): note.GeneralNote;
    xmlToPitch(mxNote: Element, inputM21: pitch.Pitch): pitch.Pitch;
    xmlToAccidental(mxAccidental: Element): pitch.Accidental;
    xmlToRest(mxRest: Element): note.GeneralNote;
    xmlNoteToGeneralNoteHelper(n: note.GeneralNote, mxNote: Element, freeSpanners?: boolean): note.GeneralNote;
    xmlToDuration(mxNote: any, inputM21: duration.Duration): duration.Duration;
    xmlBackup(mxBackup: Element): void;
    xmlForward(mxForward: Element): void;
    xmlToTie(mxNote: Element): tie.Tie;
    updateLyricsFromList(n: any, lyricList: any): void;
    xmlToLyric(mxLyric: Element, inputM21?: note.Lyric): note.Lyric;
    insertIntoMeasureOrVoice(mxElement: Element, el: Music21Object): void;
    parseMeasureAttributes(): void;
    parseMeasureNumbers(): void;
    parseAttributesTag(mxAttributes: any): void;
    handleTimeSignature(mxTime: any): void;
    xmlToTimeSignature(mxTime: any): meter.TimeSignature;
    handleClef(mxClef: any): void;
    xmlToClef(mxClef: any): clef.Clef;
    handleKeySignature(mxKey: any): void;
    xmlToKeySignature(mxKey: any): key.KeySignature;
}
declare const musicxml: {
    ScoreParser: typeof ScoreParser;
    PartParser: typeof PartParser;
    MeasureParser: typeof MeasureParser;
};
export default musicxml;
//# sourceMappingURL=xmlToM21.d.ts.map